
/**
 * Generate dispute letters for credit report issues
 */
import { CreditReportAccount, CreditReportData } from '@/utils/creditReport/types';
import { determineBureau, getBureauAddress } from './bureauUtils';
import { generateFallbackLatePaymentDisputeLetter } from '@/utils/creditReport/disputeLetters/fallbackTemplates/latePaymentLetter';

/**
 * Generate dispute letters for credit report issues
 */
export const generateDisputeLetters = async (issues: Array<any>, reportData: CreditReportData | null): Promise<any[]> => {
  try {
    console.log(`Generating dispute letters for ${issues.length} issues`);
    
    // Clear any existing letters in session storage before generating new ones
    sessionStorage.removeItem('pendingDisputeLetter');
    sessionStorage.removeItem('generatedDisputeLetters');
    sessionStorage.removeItem('autoGeneratedLetter');
    
    // Check for test mode and create fallback letters if no issues provided
    if ((reportData?.isTestMode || sessionStorage.getItem('testModeSubscription') === 'true') && 
        (!issues || issues.length === 0)) {
      console.log("Test mode detected with no issues - creating fallback letter");
      const fallbackLetter = createTestModeFallbackLetter();
      const letters = [fallbackLetter];
      const stored = storeGeneratedLetters([fallbackLetter]);
      if (stored) {
        return letters;
      }
    }
    
    // Extract user personal information from report data if available
    const userInfo = extractUserInfo(reportData);
    console.log("Extracted user info for letters:", userInfo);
    
    // Store user information in localStorage for retrieval in templates
    if (userInfo.name) localStorage.setItem('userName', userInfo.name);
    if (userInfo.address) localStorage.setItem('userAddress', userInfo.address);
    if (userInfo.city) localStorage.setItem('userCity', userInfo.city);
    if (userInfo.state) localStorage.setItem('userState', userInfo.state);
    if (userInfo.zip) localStorage.setItem('userZip', userInfo.zip);
    
    // Create a letter for each issue
    const letterPromises = issues.map(async (issue, index) => {
      // Determine bureau from issue data
      const bureauSource = issue.account?.bureau || 
        (issue.account?.accountName || '') || 
        issue.title || 
        'Experian';
        
      const bureau = determineBureau(bureauSource);
      const bureauAddress = getBureauAddress(bureau);
      
      // Generate a unique ID for the letter
      const letterId = Date.now() + index;
      
      // Determine account information from issue or defaults
      // Avoid using "Multiple Accounts" as the account name
      let accountName = issue.account?.accountName || '';
      if (!accountName || accountName.toLowerCase().includes('multiple accounts') || accountName.toLowerCase().includes('unknown account')) {
        // Use account type or generic name based on issue type
        const issueType = issue.type || 'Credit Issue';
        accountName = `${issueType.replace(' Dispute', '')} Account #${index + 1}`;
      }
      
      const accountNumber = issue.account?.accountNumber || '';
      
      // Get user info with fallbacks to ensure we have values
      const userName = userInfo.name || localStorage.getItem('userName') || localStorage.getItem('name') || "Your Name";
      const userAddress = userInfo.address || localStorage.getItem('userAddress') || "Your Address";
      const userCity = userInfo.city || localStorage.getItem('userCity') || "Your City";
      const userState = userInfo.state || localStorage.getItem('userState') || "Your State";
      const userZip = userInfo.zip || localStorage.getItem('userZip') || "Your ZIP";
      
      // Create dispute data object
      const disputeData = {
        bureau,
        accountName,
        accountNumber,
        reason: issue.type || 'Credit Error',
        description: issue.description || 'This information appears inaccurate and should be verified',
        explanation: issue.description || 'This information appears inaccurate and should be verified',
        laws: issue.laws || ["FCRA § 611"]
      };
      
      // Generate letter content based on issue type
      let letterContent = '';
      
      // For late payment issues, use the enhanced late payment template
      if (issue.type === 'late_payment') {
        letterContent = generateFallbackLatePaymentDisputeLetter();
        
        // Replace placeholders with actual values - be thorough to catch all placeholder patterns
        let updatedContent = letterContent
          .replace(/\[YOUR NAME\]/g, userName)
          .replace(/\/ArialBold/g, userName) // Replace formatting tags with name
          .replace(/\[YOUR ADDRESS\]/g, userAddress)
          .replace(/\[CITY\],\s*\[STATE\]\s*\[ZIP\]/g, `${userCity}, ${userState} ${userZip}`)
          .replace(/\[CITY\], \[STATE\] \[ZIP\]/g, `${userCity}, ${userState} ${userZip}`)
          .replace(/\[BUREAU\]/g, bureau)
          .replace(/\[BUREAU ADDRESS\]/g, bureauAddress)
          .replace(/\[ACCOUNT_NAME\]/g, accountName.toUpperCase())
          .replace(/\[ACCOUNT_NUMBER\]/g, accountNumber || 'xxxx-xxxx-xxxx-xxxx')
          .replace(/\[DATES OF REPORTED LATE PAYMENTS\]/g, 'As reported on my credit report');
          
        // If we have reportData with multiple accounts that have late payments, add them
        if (reportData && reportData.accounts && reportData.accounts.length > 0) {
          const accountsWithLatePayments = reportData.accounts.filter(account => 
            account.isNegative || 
            (account.paymentStatus && account.paymentStatus.toLowerCase().includes('late')) ||
            (account.remarks && account.remarks.some(remark => remark.toLowerCase().includes('late')))
          );
          
          if (accountsWithLatePayments.length > 1) {
            // Replace the standard single account format with multiple accounts
            const accountsSection = accountsWithLatePayments.map(account => {
              return `- **Creditor:** ${account.accountName.toUpperCase()}\n` +
                     `- **Account #:** ${account.accountNumber ? account.accountNumber : 'xxxx-xxxx-xxxx-xxxx'}\n` +
                     `- **Alleged Late Payments:** As reported on my credit report\n`;
            }).join('\n');
            
            // Replace the placeholder disputed items section with our multi-account format
            updatedContent = updatedContent.replace(
              /DISPUTED ITEMS:\n- \*\*Creditor:\*\* \[ACCOUNT_NAME\]\n- \*\*Account #:\*\* \[ACCOUNT_NUMBER\]\n- \*\*Alleged Late Payments:\*\* \[DATES OF REPORTED LATE PAYMENTS\]\n\n/,
              `DISPUTED ITEMS:\n${accountsSection}\n`
            );
          }
        }
        
        letterContent = updatedContent;
      } else {
        // For other issue types, use standard letter template
        // Generate a properly formatted dispute letter
        let standardContent = `Credit Report #: CR${Math.floor(Math.random() * 10000000)}\nToday is ${new Date().toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })}\n\n`;
        
        // Add sender information
        standardContent += `${userName}\n`;
        standardContent += `${userAddress}\n`;
        standardContent += `${userCity}, ${userState} ${userZip}\n\n`;
        
        // Add recipient information
        standardContent += `${bureau}\n`;
        standardContent += `${bureauAddress}\n\n`;
        
        // Add subject line
        standardContent += `Re: Dispute of Inaccurate Information - ${accountName}\n\n`;
        
        // Add salutation and introduction
        standardContent += `To Whom It May Concern:\n\n`;
        standardContent += `I am writing to dispute the following information in my credit report. I have identified the following item(s) that are inaccurate or incomplete:\n\n`;
        
        // Add account details
        standardContent += `DISPUTED ITEM(S):\n`;
        standardContent += `Account Name: ${accountName.toUpperCase()}\n`;
        if (accountNumber) {
          standardContent += `Account Number: ${'x'.repeat(Math.max(0, accountNumber.length - 4))}${accountNumber.slice(-4)}\n`;
        } else {
          // Generate a placeholder number if none exists
          const placeholderNum = `xx-xxxx-${1000 + index}`;
          standardContent += `Account Number: ${placeholderNum}\n`;
        }
        standardContent += `Reason for Dispute: ${disputeData.reason}\n\n`;
        
        // Add explanation
        standardContent += `${disputeData.explanation}\n\n`;
        
        // Add legal basis with Metro 2 verbiage
        standardContent += `According to the Fair Credit Reporting Act, Section 611 (15 U.S.C. § 1681i), you are required to conduct a reasonable investigation into this matter and remove or correct any information that cannot be verified. Furthermore, under the CDIA Metro 2® Format which is MANDATED for all furnishers, all aspects of an account must be reported with precise accuracy, including proper use of specific codes that communicate payment status.\n\n`;
        
        standardContent += `Per CRSA enacted, CDIA implemented laws, ANY and ALL reporting must be deleted if not CERTIFIABLY fully true, correct, complete, timely, of known ownership and responsibility, and also fully Metro 2 compliant. The information being reported fails to comply with these strict standards and must be removed immediately.\n\n`;
        
        // Add request
        standardContent += `Please investigate this matter and correct your records within the 30-day timeframe provided by the FCRA. Additionally, please provide me with notification of the results of your investigation and a free updated copy of my credit report if changes are made, as required by law.\n\n`;
        
        // Add closing
        standardContent += `Sincerely,\n\n`;
        standardContent += `${userName}\n\n`;
        
        // Add enclosures
        standardContent += `Enclosures:\n`;
        standardContent += `- Copy of Driver's License\n`;
        standardContent += `- Copy of Social Security Card\n`;
        
        letterContent = standardContent;
      }
      
      // Final cleanup of any remaining placeholders or formatting tags
      // Use a new variable instead of reassigning to letterContent
      let finalContent = letterContent
        .replace(/\/ArialBold/g, '')
        .replace(/\[YOUR NAME\]/g, userName)
        .replace(/\[YOUR ADDRESS\]/g, userAddress)
        .replace(/\[CITY\], \[STATE\] \[ZIP\]/g, `${userCity}, ${userState} ${userZip}`)
        .replace(/\[CITY\],\s*\[STATE\]\s*\[ZIP\]/g, `${userCity}, ${userState} ${userZip}`)
        .replace(/\[(.*?)\]/g, ''); // Remove any remaining brackets
      
      // Create basic letter structure with an incrementing ID to ensure each letter is unique
      return {
        id: letterId + index,
        title: `Dispute for ${accountName} - ${issue.type || 'Credit Error'}`,
        bureau: bureau,
        recipient: bureau,
        accountName: accountName,
        accountNumber: accountNumber,
        errorType: issue.type || 'Credit Error',
        content: finalContent,
        letterContent: finalContent,
        status: 'ready', // Explicitly set to 'ready', not 'draft'
        createdAt: new Date().toLocaleDateString('en-US', { 
          month: 'short', day: 'numeric', year: 'numeric' 
        }),
        bureaus: [bureau],
        laws: issue.laws || ["FCRA § 611"],
        timestamp: new Date().toISOString(),
        // Add a unique marker to identify new letters
        newLetter: true,
        analysisTimestamp: Date.now()
      };
    });
    
    // Wait for all letters to be generated
    const letters = await Promise.all(letterPromises);
    
    console.log(`Generated ${letters.length} dispute letters`);
    
    // Ensure we're storing completely fresh letters
    sessionStorage.removeItem('pendingDisputeLetter');
    sessionStorage.removeItem('generatedDisputeLetters');
    sessionStorage.removeItem('autoGeneratedLetter');
    
    // Store the letters
    const stored = storeGeneratedLetters(letters);
    
    if (stored) {
      return letters;
    } else {
      throw new Error("Failed to store generated letters");
    }
  } catch (error) {
    console.error("Error generating dispute letters:", error);
    
    // If we're in test mode and hit an error, create a fallback letter
    if (reportData?.isTestMode || sessionStorage.getItem('testModeSubscription') === 'true') {
      console.log("Test mode with error - creating fallback letter");
      const fallbackLetter = createTestModeFallbackLetter();
      const stored = storeGeneratedLetters([fallbackLetter]);
      if (stored) {
        return [fallbackLetter];
      }
    }
    
    return [];
  }
};

/**
 * Create a fallback letter for test mode
 */
function createTestModeFallbackLetter() {
  console.log("Creating test mode fallback letter");
  const bureau = 'Experian';
  const bureauAddress = getBureauAddress(bureau);
  const accountName = 'TEST ACCOUNT';
  const accountNumber = 'XXXX-XXXX-1234';
  
  // Use a let variable instead of const since we'll be modifying it
  let letterContent = `CREDIT REPORT DISPUTE LETTER\nToday's Date: ${new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })}\n\n`;
  
  // Add sender information - building the string in parts
  letterContent += `John Doe\n`;
  letterContent += `123 Main Street\n`;
  letterContent += `Anytown, CA 90210\n\n`;
  
  // Add recipient information
  letterContent += `${bureau}\n`;
  letterContent += `${bureauAddress}\n\n`;
  
  // Add subject line
  letterContent += `Re: Dispute of Inaccurate Information - ${accountName}\n\n`;
  
  // Add salutation and introduction
  letterContent += `To Whom It May Concern:\n\n`;
  letterContent += `I am writing to dispute the following information in my credit report. I have identified the following item(s) that are inaccurate or incomplete:\n\n`;
  
  // Add account details
  letterContent += `DISPUTED ITEM(S):\n`;
  letterContent += `Account Name: ${accountName}\n`;
  letterContent += `Account Number: ${accountNumber}\n`;
  letterContent += `Reason for Dispute: Inaccurate Information\n\n`;
  
  // Add explanation
  letterContent += `This account contains inaccurate information that should be verified or removed from my credit report.\n\n`;
  
  // Add legal basis
  letterContent += `According to the Fair Credit Reporting Act, Section 611 (15 U.S.C. § 1681i), you are required to conduct a reasonable investigation into this matter and remove or correct any information that cannot be verified.\n\n`;
  
  // Add request
  letterContent += `Please investigate this matter and correct your records within the 30-day timeframe provided by the FCRA. Additionally, please provide me with notification of the results of your investigation and a free updated copy of my credit report if changes are made, as required by law.\n\n`;
  
  // Add closing
  letterContent += `Sincerely,\n\n`;
  letterContent += `John Doe\n\n`;
  
  // Add enclosures
  letterContent += `Enclosures:\n`;
  letterContent += `- Copy of Driver's License\n`;
  letterContent += `- Copy of Social Security Card\n`;
  
  // Create the letter object
  return {
    id: Date.now(),
    title: `Test Mode Dispute for ${accountName}`,
    bureau: bureau,
    recipient: bureau,
    accountName: accountName,
    accountNumber: accountNumber,
    errorType: 'Inaccurate Information',
    content: letterContent,
    letterContent: letterContent,
    status: 'ready',
    createdAt: new Date().toLocaleDateString('en-US', { 
      month: 'short', day: 'numeric', year: 'numeric' 
    }),
    bureaus: [bureau],
    laws: ["FCRA § 611"],
    timestamp: new Date().toISOString(),
    newLetter: true,
    analysisTimestamp: Date.now(),
    isTestMode: true
  };
}

/**
 * Extract user information from credit report data
 */
function extractUserInfo(reportData: CreditReportData | null): { 
  name?: string; 
  address?: string; 
  city?: string; 
  state?: string; 
  zip?: string;
} {
  const userInfo: { 
    name?: string; 
    address?: string; 
    city?: string; 
    state?: string; 
    zip?: string; 
  } = {};
  
  if (!reportData) {
    console.log("No report data available for extracting user info");
    return userInfo;
  }
  
  console.log("Extracting user info from report data:", reportData.personalInfo);
  
  // Try to extract name from personal info
  if (reportData.personalInfo && reportData.personalInfo.name) {
    userInfo.name = reportData.personalInfo.name;
    console.log("Extracted name:", userInfo.name);
  }
  
  // Try to extract address from personal info
  if (reportData.personalInfo) {
    // Direct assignment if available
    if (reportData.personalInfo.address) {
      userInfo.address = reportData.personalInfo.address;
    }
    
    if (reportData.personalInfo.city) {
      userInfo.city = reportData.personalInfo.city;
    }
    
    if (reportData.personalInfo.state) {
      userInfo.state = reportData.personalInfo.state;
    }
    
    if (reportData.personalInfo.zip) {
      userInfo.zip = reportData.personalInfo.zip;
    }
    
    // If we have an address but not city/state/zip, try to parse them from the address
    if (userInfo.address && (!userInfo.city || !userInfo.state || !userInfo.zip)) {
      const address = userInfo.address;
      
      // Try to parse address into components
      const addressParts = address.split(',');
      if (addressParts.length >= 2) {
        if (!userInfo.address) {
          userInfo.address = addressParts[0].trim();
        }
        
        // Try to extract city, state, zip from the remaining parts
        const locationParts = addressParts[1].trim().split(' ');
        if (locationParts.length >= 2) {
          // Last part is likely zip code
          if (!userInfo.zip) {
            userInfo.zip = locationParts[locationParts.length - 1];
          }
          
          // Second to last part is likely state
          if (!userInfo.state) {
            userInfo.state = locationParts[locationParts.length - 2];
          }
          
          // Everything else is likely city
          if (!userInfo.city) {
            userInfo.city = locationParts.slice(0, locationParts.length - 2).join(' ');
          }
        }
      }
    }
  }
  
  console.log("Final extracted user info:", userInfo);
  return userInfo;
}

/**
 * Store generated letters in session storage
 */
export const storeGeneratedLetters = (letters: any[]): boolean => {
  try {
    // First, ensure we're clearing any existing letters
    sessionStorage.removeItem('pendingDisputeLetter');
    sessionStorage.removeItem('generatedDisputeLetters');
    sessionStorage.removeItem('autoGeneratedLetter');
    
    // Format letters to ensure they have all required fields
    const formattedLetters = letters.map(letter => {
      if (letter.content && !letter.letterContent) {
        letter.letterContent = letter.content;
      } else if (letter.letterContent && !letter.content) {
        letter.content = letter.letterContent;
      }
      
      if (!letter.bureaus && letter.bureau) {
        letter.bureaus = [letter.bureau];
      }
      
      // Always explicitly set status to 'ready', not 'draft'
      letter.status = 'ready';
      
      if (!letter.createdAt) {
        letter.createdAt = new Date().toLocaleDateString('en-US', { 
          month: 'short', day: 'numeric', year: 'numeric' 
        });
      }
      
      return letter;
    });
    
    console.log(`Storing ${formattedLetters.length} fresh formatted letters:`, formattedLetters);
    
    // Create a unique key for this batch of letters to prevent caching issues
    const timestamp = Date.now();
    sessionStorage.setItem('generatedDisputeLetters', JSON.stringify(formattedLetters));
    sessionStorage.setItem('disputeLettersTimestamp', timestamp.toString());
    
    if (formattedLetters.length > 0) {
      sessionStorage.setItem('pendingDisputeLetter', JSON.stringify(formattedLetters[0]));
    }
    
    sessionStorage.setItem('autoGeneratedLetter', 'true');
    sessionStorage.setItem('forceLettersReload', 'true');
    sessionStorage.setItem('testModeSubscription', 'true');
    
    return true;
  } catch (error) {
    console.error("Error storing letters:", error);
    return false;
  }
};
